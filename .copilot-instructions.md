# Dream Journal - Copilot AI Assistant Instructions

## Project Overview

Dream Journal is a lightweight, accessible React TypeScript application exclusively for recording, exploring, and analyzing dreams. The application focuses on simplicity, accessibility, and multi-language support.

### Core Purpose
- **Primary Goal**: Provide a quick, easy way to capture and explore dream experiences
- **Target Users**: Anyone who wants to record and analyze their dreams
- **Key Features**: Dream recording, multi-language support, local/cloud storage options

## Architecture & Technology Stack

### Frontend Stack
- **Framework**: React 19.1.1 with TypeScript 4.9.5
- **Build Tool**: Create React App 5.0.1
- **Styling**: CSS modules with responsive design
- **State Management**: React Context API with custom hooks
- **Internationalization**: react-i18next for multi-language support
- **Storage**: LocalForage for offline-first storage with cloud sync options

### Supported Languages
- English (default)
- French (fr)
- Spanish (es) 
- German (de)

### Authentication Providers
- Google
- Facebook
- GitHub
- Microsoft
- Local-only mode (no sync)

## Project Structure

```
src/
├── components/          # Reusable UI components
│   ├── Header.tsx      # Main navigation and auth
│   ├── NoteInput.tsx   # Note creation interface
│   ├── NotesList.tsx   # Note display and management
│   └── icons/          # SVG icon components
├── hooks/              # Custom React hooks
│   └── useApp.tsx      # Main application state management
├── i18n/               # Internationalization
│   └── config.ts       # Language configurations
├── services/           # Business logic and external services
│   └── storage.ts      # LocalForage storage abstractions
├── types/              # TypeScript type definitions
│   └── index.ts        # Core interfaces and types
├── App.tsx             # Main application component
└── index.tsx           # Application entry point
```

## Coding Conventions & Patterns

### TypeScript Patterns
- **Strict typing**: Use explicit types for all props and function parameters
- **Interface definitions**: Define interfaces in `src/types/index.ts`
- **Utility types**: Leverage TypeScript utility types (Partial, Omit, Pick)
- **Type exports**: Export types from type definition files

### React Patterns
- **Functional components**: Use function declarations, not arrow functions for components
- **Custom hooks**: Prefix with `use` and encapsulate complex state logic
- **Context pattern**: Use React Context for global state management
- **Prop interfaces**: Define props interfaces above each component

### Component Structure
```typescript
import React, { useState, useEffect } from 'react';
import { useTranslation } from 'react-i18next';
import { ComponentType } from '../types';
import './ComponentName.css';

interface ComponentNameProps {
  // Props definition
}

export function ComponentName({ prop1, prop2 }: ComponentNameProps) {
  const { t } = useTranslation();
  // Component logic
  
  return (
    // JSX
  );
}
```

### CSS Conventions
- **Component-scoped CSS**: Each component has its own CSS file
- **BEM methodology**: Use block__element--modifier naming
- **Responsive design**: Mobile-first approach with media queries
- **Accessibility**: Focus states, high contrast support, reduced motion
- **CSS custom properties**: Use for theming and consistent spacing

### File Naming
- **Components**: PascalCase (e.g., `NotesList.tsx`)
- **Hooks**: camelCase with 'use' prefix (e.g., `useApp.tsx`)
- **Services**: camelCase (e.g., `storage.ts`)
- **Types**: camelCase (e.g., `index.ts`)
- **CSS**: PascalCase matching component (e.g., `NotesList.css`)

## Data Models

### Note Structure
```typescript
interface Note {
  id: string;              // UUID v4
  content: string;         // User dream description, max 2000 characters
  category: NoteCategory;  // Always 'dream'
  createdAt: Date;         // Creation timestamp
  updatedAt: Date;         // Last modification timestamp
  userId?: string;         // Optional for cloud sync
}

type NoteCategory = 'dream';
```

### Application Settings
```typescript
interface AppSettings {
  language: string;                    // ISO language code
  theme: 'light' | 'dark';            // UI theme preference
  storageMode: 'local' | 'cloud';     // Storage preference
}
```

## State Management

### App Context Pattern
- **Provider**: `AppProvider` wraps the entire application
- **Hook**: `useApp()` provides state and actions
- **State structure**: Includes notes, settings, user, and loading states
- **Actions**: Async functions for data operations (add, update, delete notes)

### Storage Strategy
- **Primary**: LocalForage for offline-first experience
- **Sync**: Optional cloud sync with authentication
- **Data persistence**: Automatic save on all operations
- **Error handling**: Graceful fallbacks for storage failures

## Internationalization (i18n)

### Translation Key Structure
```typescript
// Nested structure for organization
translation: {
  title: 'App Title',
  categories: {
    dream: 'Dream',
    idea: 'Idea'
  },
  auth: {
    signIn: 'Sign In',
    signOut: 'Sign Out'
  }
}
```

### Usage Pattern
```typescript
const { t } = useTranslation();
return <button>{t('auth.signIn')}</button>;
```

### Adding New Languages
1. Add translation object to `src/i18n/config.ts`
2. Include all existing keys with appropriate translations
3. Test with language switcher component

## Component Development Guidelines

### Form Components
- **Controlled inputs**: Use React state for form values
- **Validation**: Client-side validation with user feedback
- **Accessibility**: Proper labels, ARIA attributes, keyboard navigation
- **Auto-focus**: Focus management for better UX

### Modal Components
- **Overlay pattern**: Click outside to close
- **Event bubbling**: Stop propagation on modal content
- **Escape key**: Close on ESC key press
- **Focus management**: Trap focus within modal

### List Components
- **Key props**: Use stable, unique keys for list items
- **Empty states**: Provide helpful empty state messages
- **Loading states**: Show appropriate loading indicators
- **Action buttons**: Clear, accessible action controls

## Testing Patterns

### Component Testing
- **React Testing Library**: Preferred testing framework
- **User-centric tests**: Test behavior, not implementation
- **Accessibility testing**: Include keyboard and screen reader tests
- **Mock external dependencies**: Services, storage, APIs

### Test Structure
```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  it('should render with correct text', () => {
    render(<ComponentName />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });
});
```

## Build & Deployment

### Development
```bash
npm start          # Development server (localhost:3000)
npm test           # Run tests in watch mode
npm run build      # Production build
```

### Production Build
- **Optimization**: Automatic minification and bundling
- **Asset optimization**: Images, CSS, and JS optimization
- **PWA features**: Service worker for offline functionality
- **Static hosting**: Ready for deployment to any static host

### Performance Considerations
- **Code splitting**: Automatic with Create React App
- **Lazy loading**: Implement for large components
- **Memoization**: Use React.memo for expensive renders
- **Bundle analysis**: Regular bundle size monitoring

## Best Practices for AI Assistant

### Code Generation
1. **Follow existing patterns**: Match the established component structure
2. **Include TypeScript types**: Always provide proper type definitions
3. **Add internationalization**: Include translation keys for user-facing text
4. **Implement accessibility**: Add ARIA labels, keyboard support, focus management
5. **Error handling**: Include try-catch blocks and user feedback
6. **Responsive design**: Ensure mobile-friendly layouts

### Component Creation Checklist
- [ ] TypeScript interface for props
- [ ] Proper imports (React, hooks, types, styles)
- [ ] Translation setup with useTranslation
- [ ] Accessibility attributes
- [ ] CSS file with responsive styles
- [ ] Error boundaries where appropriate
- [ ] Loading states for async operations

### Common Pitfalls to Avoid
- **Direct DOM manipulation**: Use React patterns instead
- **Inline styles**: Use CSS classes for better maintainability
- **Missing keys in lists**: Always provide unique keys
- **Uncontrolled inputs**: Use controlled components consistently
- **Missing error handling**: Always handle potential failures
- **Hardcoded text**: Use translation keys for all user-facing text

## Feature Development Guidelines

### Dream Feature Enhancements
Since the app is now focused exclusively on dreams, new features should enhance the dream journaling experience:
1. Dream analysis tools
2. Dream pattern recognition
3. Dream tags and themes
4. Dream visualization features

### Adding New Languages
1. Add translation object to `src/i18n/config.ts`
2. Include complete translation coverage
3. Test language switching functionality
4. Update language selection UI if needed

### Storage Enhancements
1. Maintain backward compatibility with existing data
2. Add migration logic for schema changes
3. Test both local and cloud storage scenarios
4. Handle edge cases (storage full, network issues)

## Security Considerations

### Data Handling
- **Local storage**: Sensitive data should be encrypted
- **Cloud sync**: Use secure authentication flows
- **Input validation**: Sanitize all user inputs
- **XSS prevention**: Use React's built-in protections

### Authentication
- **OAuth flows**: Follow provider-specific best practices
- **Token management**: Secure storage and rotation
- **Privacy**: Clear data handling policies
- **Offline mode**: Graceful degradation without auth

This document serves as a comprehensive guide for AI assistants working on the Dream Journal project. Always refer to these patterns and conventions when generating or modifying code.